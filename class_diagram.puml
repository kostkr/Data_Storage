@startuml
class CLI {
    -GraphManager& graphManager
    -CommandManager& commandManager
    +CLI(GraphManager& graphManager, CommandManager& commandManager)
    +void run()
}

CLI -> GraphManager
CLI --> CommandManager

class CommandManager {
    - std::map<std::string, std::function<Command*()>> commandMap
    + void registryCommand(std::string name, std::function<Command*()> command)
    + void executeCommand(std::string commandName)
}

class Command {
    + void execute()
}

class InitGraphCommand{
    + void execute()
}

class AddNodeCommand{
    + void execute()
}

class AddEdgeCommand{
    + void execute()
}

class DeleteNodeCommand{
    + void execute()
}

class DeleteEdgeCommand{
    + void execute()
}

class DisplayNodeCommand{
    + void execute()
}

class DisplayEdgeCommand{
    + void execute()
}

class DisplayGraphCommand{
    + void execute()
}

InitGraphCommand -> Command
AddNodeCommand -> Command
AddEdgeCommand -> Command
DeleteNodeCommand -> Command
DeleteEdgeCommand -> Command
DisplayNodeCommand -> Command
DisplayEdgeCommand -> Command
DisplayGraphCommand -> Command


class GraphManager {
    map<string, Graph*> graphs
    Graph* currentGraph
    +void createGraph(string graphName)
    +void deleteGraph(string graphName)
    +void switchGraph(string graphName)
    +Graph* getCurrentGraph()
    +void displayGraphs()
}

GraphManager --> Graph

class Graph {
    int id
    string name
    + std::vector<TNode> nodes
    + std::vector<TEdge> edges
    + void addNode(TNode node)
    + void addEdge(TEdge edge)
    + void removeNode(TNode node)
    + void removeEdge(TEdge edge)
    + void displayGraph()
}

class "Node<T>" {
      int id
      T data
    + Node(T data)
    + T getData()
    + void setData(T data)
}

class "Edge<T>" {
      int id
      Node<T> source
      Node<T> destination
      T metadata
      double weight // optional
    + Edge(Node<T> source, Node<T> destination, T metadata)
    + Node<T> getSource()
    + Node<T> getDestination()
    + T getMetadata()
    + void setMetadata(T metadata)
}

class GraphRepository {
    + void serialize(Graph<TNode, TEdge> graph)
    + Graph deserialize(std::string& filename)
}

class GraphView {
    + void displayGraph(Graph& graph)
    + void displayNodeDetails(Node<T> node)
    + void displayEdgeDetails(Edge<T> edge)
}

Graph "1" *-- "many" "Node<T>"
Graph "1" *-- "many" "Edge<T>"
"Edge<T>" "many" o-- "1" "Node<T>"

GraphRepository ..> "Graph"
GraphManager ..> "GraphRepository"

GraphView -> Graph

CommandManager "1" *-- "many" "Command"


' patterns:
' 1) Service layer - CommandManager implements the pattern because it acts as an intermediary between the user interface (in this case, the CLI) and the core business logic (represented by the commands and graph operations)
' 2) Facade - CLI providing a unified interface to the underlying subsystems like CommandManager
' 3) Factory Method - CommandManager provide the REGISTER_COMMAND macro simplifies the process of registering commands with their creators, making the system more flexible and extensible by allowing new commands to be added without modifying existing code.
' 4) Plugin - Command provide method execute() to implement new command and next register this in CommandManager. It allows to provide new commands which user requires.
' 5) Repository - GraphRepository persist graph as file for next use in RAG system.
' +6) Metadata Mapping - The Edge class can use metaprogramming to implement weights, which helps determine the strength of the relationship between pieces of information, enabling more efficient analysis and processing
' 7) MVC - Graph(model), CommandManager(controller), GraphView(view)
' + 8) Foreign Key Mapping - The Edge class contains a reference to the Node class to establish dependencies between the data.
' 9) Serialized LOB - GraphRepository can persist and upload graph as single file to simply process of sharing data between applications.
' 10) Application Controller - CommandManager control execution of all incoming commands as a gateway.
' 11) Data Transfer Object - GraphRepository can generate file to transfer graph tp another application as llama-index for generate index for RAG.
' 12) Registry - CommandManager allow registry new method to extend application.
' 13) Value Object - Command classes can be identified by name but not id.
' 14) Special Case -  GraphManage has special case when graph is not initialized or uploaded by user.

@enduml
